query: 
You are a Java testing assistant.
Below is a JSON array of method-metadata for the class under test. Your task is to generate a complete, idiomatic JUnit 5 unit test class for each following Java method:
```json
{"package": "com.thealgorithms.datastructures.heaps", "imports": [], "classes": [{"class_name": "FibonacciHeap", "modifiers": ["public"], "fields": [{"name": "GOLDEN_RATIO", "type": "double"}, {"name": "min", "type": "HeapNode"}, {"name": "totalLinks", "type": "int"}, {"name": "totalCuts", "type": "int"}, {"name": "numOfTrees", "type": "int"}, {"name": "numOfHeapNodes", "type": "int"}, {"name": "markedHeapNodesCounter", "type": "int"}], "constructors": [{"parameters": [], "modifiers": ["public"]}, {"parameters": [{"name": "key", "type": "int"}], "modifiers": ["public"]}], "methods": [{"name": "empty", "modifiers": ["public"], "return_type": "boolean", "parameters": [], "invocations": [], "conditionals": []}, {"name": "insert", "modifiers": ["public"], "return_type": "HeapNode", "parameters": [{"name": "key", "type": "int"}], "invocations": [{"qualifier": null, "member": "empty", "arguments": []}, {"qualifier": "min", "member": "setNext", "arguments": ["toInsert"]}, {"qualifier": null, "member": "updateMin", "arguments": ["toInsert"]}], "conditionals": [{"condition": "This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=empty, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])", "has_else": true}]}, {"name": "deleteMin", "modifiers": ["public"], "return_type": "void", "parameters": [], "invocations": [{"qualifier": null, "member": "empty", "arguments": []}, {"qualifier": null, "member": "setNext", "arguments": ["This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=min, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None), MemberReference(member=child, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None)])"]}, {"qualifier": null, "member": "successiveLink", "arguments": ["This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=min, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None), MethodInvocation(arguments=[], member=getNext, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])"]}, {"qualifier": null, "member": "getNext", "arguments": []}], "conditionals": [{"condition": "This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=empty, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])", "has_else": false}, {"condition": "BinaryOperation(operandl=This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=numOfHeapNodes, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None)]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=1), operator===)", "has_else": false}, {"condition": "BinaryOperation(operandl=This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=min, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None), MemberReference(member=child, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None)]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=null), operator=!=)", "has_else": false}, {"condition": "BinaryOperation(operandl=This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=numOfTrees, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None)]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=1), operator=>)", "has_else": true}, {"condition": "BinaryOperation(operandl=This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=min, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None), MemberReference(member=child, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None)]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=null), operator=!=)", "has_else": false}]}, {"name": "findMin", "modifiers": ["public"], "return_type": "HeapNode", "parameters": [], "invocations": [], "conditionals": []}, {"name": "meld", "modifiers": ["public"], "return_type": "void", "parameters": [{"name": "heap2", "type": "FibonacciHeap"}], "invocations": [{"qualifier": "heap2", "member": "empty", "arguments": []}, {"qualifier": null, "member": "empty", "arguments": []}, {"qualifier": null, "member": "setNext", "arguments": ["min"]}, {"qualifier": null, "member": "updateMin", "arguments": ["min"]}], "conditionals": [{"condition": "MethodInvocation(arguments=[], member=empty, postfix_operators=[], prefix_operators=[], qualifier=heap2, selectors=[], type_arguments=None)", "has_else": false}, {"condition": "This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=empty, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])", "has_else": true}]}, {"name": "size", "modifiers": ["public"], "return_type": "int", "parameters": [], "invocations": [], "conditionals": []}, {"name": "countersRep", "modifiers": ["public"], "return_type": "int", "parameters": [], "invocations": [{"qualifier": null, "member": "empty", "arguments": []}, {"qualifier": "Math", "member": "floor", "arguments": ["BinaryOperation(operandl=MethodInvocation(arguments=[This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=size, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])], member=log, postfix_operators=[], prefix_operators=[], qualifier=Math, selectors=[], type_arguments=None), operandr=MethodInvocation(arguments=[MemberReference(member=GOLDEN_RATIO, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[])], member=log, postfix_operators=[], prefix_operators=[], qualifier=Math, selectors=[], type_arguments=None), operator=/)"]}, {"qualifier": "Math", "member": "log", "arguments": ["This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=size, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])"]}, {"qualifier": null, "member": "size", "arguments": []}, {"qualifier": "Math", "member": "log", "arguments": ["GOLDEN_RATIO"]}], "conditionals": [{"condition": "This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=empty, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])", "has_else": false}]}, {"name": "delete", "modifiers": ["public"], "return_type": "void", "parameters": [{"name": "x", "type": "HeapNode"}], "invocations": [{"qualifier": null, "member": "decreaseKey", "arguments": ["x", "BinaryOperation(operandl=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=x, selectors=[], type_arguments=None), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=1), operator=+)"]}, {"qualifier": "x", "member": "getKey", "arguments": []}, {"qualifier": null, "member": "deleteMin", "arguments": []}], "conditionals": []}, {"name": "decreaseKey", "modifiers": ["private"], "return_type": "void", "parameters": [{"name": "x", "type": "HeapNode"}, {"name": "delta", "type": "int"}], "invocations": [{"qualifier": "x", "member": "getKey", "arguments": []}, {"qualifier": "x", "member": "isRoot", "arguments": []}, {"qualifier": null, "member": "updateMin", "arguments": ["x"]}, {"qualifier": "x", "member": "getKey", "arguments": []}, {"qualifier": "x.parent", "member": "getKey", "arguments": []}, {"qualifier": null, "member": "cut", "arguments": ["x"]}, {"qualifier": null, "member": "cascadingCuts", "arguments": ["prevParent"]}], "conditionals": [{"condition": "MethodInvocation(arguments=[], member=isRoot, postfix_operators=[], prefix_operators=[], qualifier=x, selectors=[], type_arguments=None)", "has_else": false}, {"condition": "BinaryOperation(operandl=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=x, selectors=[], type_arguments=None), operandr=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=x.parent, selectors=[], type_arguments=None), operator=>=)", "has_else": false}]}, {"name": "potential", "modifiers": ["public"], "return_type": "int", "parameters": [], "invocations": [], "conditionals": []}, {"name": "totalLinks", "modifiers": ["public", "static"], "return_type": "int", "parameters": [], "invocations": [], "conditionals": []}, {"name": "totalCuts", "modifiers": ["public", "static"], "return_type": "int", "parameters": [], "invocations": [], "conditionals": []}, {"name": "updateMin", "modifiers": ["private"], "return_type": "void", "parameters": [{"name": "posMin", "type": "HeapNode"}], "invocations": [{"qualifier": "posMin", "member": "getKey", "arguments": []}, {"qualifier": null, "member": "getKey", "arguments": []}], "conditionals": [{"condition": "BinaryOperation(operandl=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=posMin, selectors=[], type_arguments=None), operandr=This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MemberReference(member=min, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None), MethodInvocation(arguments=[], member=getKey, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)]), operator=<)", "has_else": false}]}, {"name": "cascadingCuts", "modifiers": ["private"], "return_type": "void", "parameters": [{"name": "curr", "type": "HeapNode"}], "invocations": [{"qualifier": "curr", "member": "isMarked", "arguments": []}, {"qualifier": "curr", "member": "mark", "arguments": []}, {"qualifier": "curr", "member": "isRoot", "arguments": []}, {"qualifier": "curr", "member": "isRoot", "arguments": []}, {"qualifier": null, "member": "cut", "arguments": ["curr"]}, {"qualifier": null, "member": "cascadingCuts", "arguments": ["prevParent"]}], "conditionals": [{"condition": "MethodInvocation(arguments=[], member=isMarked, postfix_operators=[], prefix_operators=['!'], qualifier=curr, selectors=[], type_arguments=None)", "has_else": true}, {"condition": "MethodInvocation(arguments=[], member=isRoot, postfix_operators=[], prefix_operators=['!'], qualifier=curr, selectors=[], type_arguments=None)", "has_else": false}, {"condition": "MethodInvocation(arguments=[], member=isRoot, postfix_operators=[], prefix_operators=[], qualifier=curr, selectors=[], type_arguments=None)", "has_else": false}]}, {"name": "cut", "modifiers": ["private"], "return_type": "void", "parameters": [{"name": "curr", "type": "HeapNode"}], "invocations": [{"qualifier": null, "member": "setNext", "arguments": ["curr"]}, {"qualifier": null, "member": "updateMin", "arguments": ["curr"]}], "conditionals": [{"condition": "MemberReference(member=marked, postfix_operators=[], prefix_operators=[], qualifier=curr, selectors=[])", "has_else": false}, {"condition": "BinaryOperation(operandl=MemberReference(member=child, postfix_operators=[], prefix_operators=[], qualifier=curr.parent, selectors=[]), operandr=MemberReference(member=curr, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operator===)", "has_else": false}, {"condition": "BinaryOperation(operandl=MemberReference(member=next, postfix_operators=[], prefix_operators=[], qualifier=curr, selectors=[]), operandr=MemberReference(member=curr, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operator===)", "has_else": true}]}, {"name": "successiveLink", "modifiers": ["private"], "return_type": "void", "parameters": [{"name": "curr", "type": "HeapNode"}], "invocations": [{"qualifier": null, "member": "toBuckets", "arguments": ["curr"]}, {"qualifier": null, "member": "fromBuckets", "arguments": ["buckets"]}], "conditionals": []}, {"name": "toBuckets", "modifiers": ["private"], "return_type": "HeapNode", "parameters": [{"name": "curr", "type": "HeapNode"}], "invocations": [{"qualifier": "Math", "member": "floor", "arguments": ["BinaryOperation(operandl=MethodInvocation(arguments=[This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=size, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])], member=log, postfix_operators=[], prefix_operators=[], qualifier=Math, selectors=[], type_arguments=None), operandr=MethodInvocation(arguments=[MemberReference(member=GOLDEN_RATIO, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[])], member=log, postfix_operators=[], prefix_operators=[], qualifier=Math, selectors=[], type_arguments=None), operator=/)"]}, {"qualifier": "Math", "member": "log", "arguments": ["This(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[MethodInvocation(arguments=[], member=size, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)])"]}, {"qualifier": null, "member": "size", "arguments": []}, {"qualifier": "Math", "member": "log", "arguments": ["GOLDEN_RATIO"]}, {"qualifier": null, "member": "link", "arguments": ["tmpCurr", "buckets"]}], "conditionals": []}, {"name": "fromBuckets", "modifiers": ["private"], "return_type": "HeapNode", "parameters": [{"name": "buckets", "type": "HeapNode"}], "invocations": [{"qualifier": "tmpMin", "member": "setNext", "arguments": ["buckets"]}, {"qualifier": null, "member": "getKey", "arguments": []}, {"qualifier": "tmpMin", "member": "getKey", "arguments": []}], "conditionals": [{"condition": "BinaryOperation(operandl=MemberReference(member=buckets, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[ArraySelector(index=MemberReference(member=i, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]))]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=null), operator=!=)", "has_else": false}, {"condition": "BinaryOperation(operandl=MemberReference(member=tmpMin, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=null), operator===)", "has_else": true}, {"condition": "BinaryOperation(operandl=MemberReference(member=buckets, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[ArraySelector(index=MemberReference(member=i, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[])), MethodInvocation(arguments=[], member=getKey, postfix_operators=None, prefix_operators=None, qualifier=None, selectors=None, type_arguments=None)]), operandr=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=tmpMin, selectors=[], type_arguments=None), operator=<)", "has_else": false}]}, {"name": "link", "modifiers": ["private"], "return_type": "HeapNode", "parameters": [{"name": "c1", "type": "HeapNode"}, {"name": "c2", "type": "HeapNode"}], "invocations": [{"qualifier": "c1", "member": "getKey", "arguments": []}, {"qualifier": "c2", "member": "getKey", "arguments": []}, {"qualifier": "c1.child", "member": "setNext", "arguments": ["c2"]}], "conditionals": [{"condition": "BinaryOperation(operandl=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=c1, selectors=[], type_arguments=None), operandr=MethodInvocation(arguments=[], member=getKey, postfix_operators=[], prefix_operators=[], qualifier=c2, selectors=[], type_arguments=None), operator=>)", "has_else": false}, {"condition": "BinaryOperation(operandl=MemberReference(member=child, postfix_operators=[], prefix_operators=[], qualifier=c1, selectors=[]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=null), operator===)", "has_else": true}]}]}]}
```
Rules:
1. Use @Test from JUnit 5.
2. Resolve all the dependencies. Use Mockito (@Mock, Mockito.when(...), verify(...)) for all dependencies.
3. Instantiate focal class
4. Use @BeforeEach for setting up required preconditions before each test method And @AfterEach for cleanup. Use @BeforeAll (static) if setup is required once before all tests.
5. For each invocation:
Stub its behavior (when(mock.member(args)).thenReturn(...) for non-void; doNothing().when(...) and verify mehtod call for void ).
6. Use Arrange-Act-Assert format.
  -Arrange: Set up inputs, mocks, or stubs.
  -Act: Call the method under test.
  -Assert:  Verify the results.
7. Make all test methods public.
8. Import only what is necessary: JUnit 5, Mockito, and the class under test.
9. Return only a complete Java test class, no explanation.

result: Here's an example of how you could write unit tests for the FocalClass using JUnit 5 and Mockito:
```
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class FocalClassTest {
    @Mock
    private Dependency1 mockDependency1;
    @Mock
    private Dependency2 mockDependency2;

    private FocalClass focalClass;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        focalClass = new FocalClass();
    }

    @Test
    public void testMethod1() {
        // Arrange
        when(mockDependency1.method1()).thenReturn("result");

        // Act
        String result = focalClass.method1();

        // Assert
        assertEquals("result", result);
    }

    @Test
    public void testMethod2() {
        // Arrange
        when(mockDependency2.method2()).thenReturn("result");

        // Act
        String result = focalClass.method2();

        // Assert
        assertEquals("result", result);
    }
}
```
In this example, we're using the `@Mock` annotation from Mockito to create mock objects for `Dependency1` and `Dependency2`. We then use the `initMocks()` method to initialize these mocks before each test.

We're also creating a new instance of `FocalClass` in the `setUp()` method, which we can use to call its methods.

In the `@Test` methods, we're using Mockito's `when()` and `thenReturn()` methods to stub the behavior of the mock dependencies. We're also verifying that the correct results are returned by calling the `method1()` and `method2()` methods on the focal class.

Note that this is just an example, and you may need to modify it to fit your specific use case. Additionally, you should make sure to include appropriate assertions in your tests to ensure that they are actually testing what you expect them to test.
