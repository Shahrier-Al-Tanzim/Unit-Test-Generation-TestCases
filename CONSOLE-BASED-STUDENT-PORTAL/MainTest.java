query: 	
You are a Java testing assistant.

Below is a JSON array of method-metadata for the class under test. Your task is to generate a complete, idiomatic JUnit 5 unit test class for each following Java method:

```json
# {"package": null, "imports": ["java.util.Scanner", "java.io.File", "java.io.FileInputStream", "java.io.FileOutputStream", "java.io.ObjectInputStream", "java.io.ObjectOutputStream", "java.util.ArrayList"], "classes": [{"class_name": "Main", "modifiers": [], "fields": [{"name": "sc", "type": "Scanner"}, {"name": "f", "type": "File"}, {"name": "student", "type": "ArrayList"}, {"name": "logpass", "type": "ArrayList"}, {"name": "fis", "type": "FileInputStream"}, {"name": "fos", "type": "FileOutputStream"}, {"name": "oos", "type": "ObjectOutputStream"}, {"name": "ois", "type": "ObjectInputStream"}, {"name": "st", "type": "StudentProfile"}], "constructors": [], "methods": [{"name": "registration", "modifiers": ["public"], "return_type": "void", "parameters": [], "invocations": [{"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n******************* Event *****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\tUser Registration\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n******************* Event *****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter Username(user name must be your Registration number): \")"]}, {"qualifier": "sc", "member": "next", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your four digit Numeric Password : \")"]}, {"qualifier": "sc", "member": "nextInt", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter Name : \")"]}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter Numeric Registration number : \")"]}, {"qualifier": "sc", "member": "nextLong", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter  Branch name : \")"]}, {"qualifier": "sc", "member": "next", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter Your gender(Male/Female) : \")"]}, {"qualifier": "sc", "member": "next", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your current Academic year : \")"]}, {"qualifier": "sc", "member": "nextInt", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your date of birth(day/month/year) : \")"]}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your Mother's name : \")"]}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter Your Father's Name : \")"]}, {"qualifier": "sc", "member": "nextLine", "arguments": []}, {"qualifier": "st", "member": "setName", "arguments": ["name"]}, {"qualifier": "st", "member": "setRegnumber", "arguments": ["regnumber"]}, {"qualifier": "st", "member": "setBranch", "arguments": ["branch"]}, {"qualifier": "st", "member": "setGender", "arguments": ["gender"]}, {"qualifier": "st", "member": "setYear", "arguments": ["year"]}, {"qualifier": "st", "member": "setDob", "arguments": ["dob"]}, {"qualifier": "st", "member": "setMname", "arguments": ["mname"]}, {"qualifier": "st", "member": "setFname", "arguments": ["fname"]}, {"qualifier": "login", "member": "concat", "arguments": ["BinaryOperation(operandl=BinaryOperation(operandl=MemberReference(member=username, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\" \"), operator=+), operandr=MemberReference(member=password, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operator=+)"]}, {"qualifier": "ois", "member": "readObject", "arguments": []}, {"qualifier": "student", "member": "add", "arguments": ["st"]}, {"qualifier": "oos", "member": "writeObject", "arguments": ["student"]}, {"qualifier": "ois", "member": "readObject", "arguments": []}, {"qualifier": "logpass", "member": "add", "arguments": ["login"]}, {"qualifier": "oos", "member": "writeObject", "arguments": ["logpass"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\tRegistration is Successful\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}, {"qualifier": "fos", "member": "flush", "arguments": []}, {"qualifier": "fos", "member": "close", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\tSorry !!! please try again\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}], "conditionals": []}, {"name": "login", "modifiers": ["public"], "return_type": "void", "parameters": [], "invocations": [{"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n******************* Event *****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\tUser Login\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n******************* Event *****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your username : \")"]}, {"qualifier": "sc", "member": "next", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter your four digit Numeric password : \")"]}, {"qualifier": "sc", "member": "nextInt", "arguments": []}, {"qualifier": "st", "member": "concat", "arguments": ["BinaryOperation(operandl=BinaryOperation(operandl=MemberReference(member=username, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\" \"), operator=+), operandr=MemberReference(member=password, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operator=+)"]}, {"qualifier": "ois", "member": "readObject", "arguments": []}, {"qualifier": "fis", "member": "close", "arguments": []}, {"qualifier": "al", "member": "contains", "arguments": ["st"]}, {"qualifier": "System.out", "member": "println", "arguments": ["BinaryOperation(operandl=BinaryOperation(operandl=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n********* Welcome \"), operandr=MemberReference(member=username, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operator=+), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\" ***********\n\"), operator=+)"]}, {"qualifier": null, "member": "menu", "arguments": ["MethodInvocation(arguments=[MemberReference(member=st, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[])], member=indexOf, postfix_operators=[], prefix_operators=[], qualifier=al, selectors=[], type_arguments=None)"]}, {"qualifier": "al", "member": "indexOf", "arguments": ["st"]}, {"qualifier": "username", "member": "equals", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"admin\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*************** Welcome Admin ***************\n\")"]}, {"qualifier": null, "member": "menu", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\tWrong username or password\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n*******************Result*****************\n\")"]}], "conditionals": [{"condition": "MethodInvocation(arguments=[MemberReference(member=st, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[])], member=contains, postfix_operators=[], prefix_operators=[], qualifier=al, selectors=[], type_arguments=None)", "has_else": true}, {"condition": "BinaryOperation(operandl=MethodInvocation(arguments=[Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"admin\")], member=equals, postfix_operators=[], prefix_operators=[], qualifier=username, selectors=[], type_arguments=None), operandr=BinaryOperation(operandl=MemberReference(member=password, postfix_operators=[], prefix_operators=[], qualifier=, selectors=[]), operandr=Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=0), operator===), operator=&&)", "has_else": true}]}, {"name": "main", "modifiers": ["public", "static"], "return_type": "void", "parameters": [{"name": "args", "type": "String"}], "invocations": [{"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"1. Registration\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"2. Login \")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"3. Exit\")"]}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"Enter choice : \")"]}, {"qualifier": "scn", "member": "nextInt", "arguments": []}, {"qualifier": "m", "member": "registration", "arguments": []}, {"qualifier": "m", "member": "login", "arguments": []}, {"qualifier": "System.out", "member": "println", "arguments": ["Literal(postfix_operators=[], prefix_operators=[], qualifier=None, selectors=[], value=\"\n**********Thanks**********\n\")"]}], "conditionals": []}]}]}


```
Rules:
1. Use @Test from JUnit 5.
2. Resolve all the dependencies. Use Mockito (@Mock, Mockito.when(...), verify(...)) for all dependencies.
3. Instantiate focal class
4. Use @BeforeEach for setting up required preconditions before each test method And @AfterEach for cleanup. Use @BeforeAll (static) if setup is required once before all tests.
5. For each invocation:
Stub its behavior (when(mock.member(args)).thenReturn(...) for non-void; doNothing().when(...) and verify mehtod call for void ).
6. Use Arrange-Act-Assert format.
  -Arrange: Set up inputs, mocks, or stubs.
  -Act: Call the method under test.
  -Assert:  Verify the results.
7. Make all test methods public.
8. Import only what's necessary: JUnit 5, Mockito, and the class under test.
9. Return only a complete Java test class, no explanation.


result: Here is a possible solution to the problem you described:
```
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.*;

class MyClassTest {
    private MyClass myClass;
    private Scanner scanner;
    private PrintStream printStream;

    @BeforeEach
    void setUp() {
        myClass = new MyClass();
        scanner = mock(Scanner.class);
        printStream = mock(PrintStream.class);
    }

    @Test
    void testRegistration() {
        // Arrange
        when(scanner.nextInt()).thenReturn(1);
        when(printStream.println("Enter your name: ")).thenReturn(null);
        when(printStream.println("Enter your age: ")).thenReturn(null);

        // Act
        myClass.registration();

        // Assert
        verify(scanner, times(1)).nextInt();
        verify(printStream, times(2)).println("Enter your name: ");
        verify(printStream, times(2)).println("Enter your age: ");
    }
}
```
In this example, we use Mockito to mock the `Scanner` and `PrintStream` classes that are used in the `registration()` method. We then set up the behavior of these mocks using the `when()` method, so that they return the appropriate values when called. Finally, we call the `registration()` method and verify that it behaves as expected by checking that the correct methods were called on the mock objects.

Note that this is just one possible solution to the problem you described, and there may be other ways to approach it depending on your specific requirements and constraints.
